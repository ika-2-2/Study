//変数提言

// letは再代入が可能な変数提言
let a = 1;
a = 2;

//constは再代入が不可能な変数提言
const b = "Hello World";
b = "Hello TypeScript";  //←これは無理

//しかし、オブジェクトの変更は可能
const obj = {a: 1};
obj = {a: 2};   //再代入は無理、
obj.a = 2;      //これはOK（プロパティの変更）

const list = [1, 2, 3];
list = [2, 3, 4]; //再代入は無理、
list[0] = 1;   //要素の変更はOK
list.push(3); //これも要素の変更だからOK

//変数にどんな値を入れるか指定できる。事故防止
const num: number = 123;
const str: string = "hello";

let x = 1;     //型推論という、型を自動で判断する機能がある

for (let i = 0; i < 3; i++) {  //こういう場合以外は基本型注釈を書いた方がいいと思う
    console.log(i);
};

//varは使わない！

//boolean型
const is_Done = false;
const is_Ok: boolean = true;

//number型
if (0.1 === .1 && 5.0 === 5.) {
    //これはtrue
}

//2進数、８進数、16進数の書き方はそれぞれ先頭に 0b, 0o, 0x をつければ書ける。
const sinsu = {  
    s2: 0b1010,  //2進数
    s8: 0o755,  //8進数
    s16: 0xfff,  //16進数
};

//区切り文字
100_000_000 //1億

//Nanとは
//Not a Numberの略。
//数値にならない場合帰ってくる値
const hello = parseInt("hello");
console.log(hello); //出力はNan

//Infinity
console.log(1 / 0); //無限大なのでInfinityが返ってくる

//小数計算の誤差
0.1 + 0.2 === 0.3; //false
/*
javascriptでは、10進数の0.2は有限小数だが,2進数の0.2は無限小数(循環小数)になるため、
計算を工夫しないといけない
*/
0.5 + 0.25 === 0.75; //true
//上の場合、どちらも二進数で有限小数になるためtrue

//小数計算の誤差を解決するために、一度整数に桁上げして計算し、もとの桁を下げる方法がある。
// 例
110 * 1.1; // 121.00000000000001
//そこで、110と桁上げした税率11を掛け算してから、10で割ってみる
(110 * 11) / 10 === 121; // true

//この方法を使う場合は、桁を戻した数値は小数になることがあり、その値には小数計算誤差問題が残り続けることに注意